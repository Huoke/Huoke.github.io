# 1、介绍
## 1.1、版权和许可
## 1.2、免责声明
## 1.3、学分/贡献者
## 1.4、反馈
## 1.5、翻译
# 2、TCP Keepalive HOW TO
keep TCP alive。这意味着您将能够检查已连接的套接字（也称为TCP套接字），并确定连接是否仍在运行或是否已断开。
## 2.1、什么是TCP keepalive？
keepalive概念很简单:当我们建立一个CTP连接时，会在内核中关联一组计时器。其中一些计时器就会专门来处理keepalive。当keepalive定时器到0时，会向对端发送一个keepalive探测包，它是没有数据的，并且ACK便签打开。由于TCP/IP规范是一种重复的ACK、面向流的协议。所以你将收到来自远方主机的回复(没有设置keepalive的TCP/IP)，没有数据的ACK确认包。

如果系统收到keepalive探测包返回的ACK包，那么久可以确定网络正常运行，从而不必担心在自己的应用层中没有实现心跳来判断网络状况。实际上TCP是允许处理没有数据的包的，所以没有数据的包对用户程序来说没有危害。

这个流程是很有用的，因为如果对端失去链接：比如路由器重启，后者网线拔掉，或者对端的机器断电。这种情况下就可以判断网络连接已经断开。当然有数据发送时可以，没有数据发送时这种网络监测就更重要了。

这里需要注意哦keepalive探测包返回值：
- 有返回值
- 无返回值
## 2.2、为什么使用TCP keepalive？
没有认识keepalive时，你可以过得很快乐，如果你读到这篇文章，你可能会试图理解keepalive是否是解决你问题的一种可能的方法。要么是这样，要么你真的没有什么更有趣的事要做了，那也没关系。:)

Keepalive是非侵入性的，在大多数情况下，如果你有疑问，你可以打开它，而不会有做错事的风险。但请记住，它会产生额外的网络流量，这会对路由器和防火墙产生影响。这就是keepalive攻击！

一句话：使用前先想好！

下一节我们讨论keepalive的两个目的:
- 检测死对等点(这里需要在仔细解释一下)
- 防止由于网络不活动而断开的连接(这里需要在仔细解释一下)
## 2.3、检查死对等点
keepalive探测包可以通知你当对端挂掉时，对端挂掉有几中可能: 
1. 比如内核错误(kernel panic)或者粗暴的结束点对端进程(向任务管理器中直接结束掉进程，有些系统会提供FIN包，有些则不会)。
2. 另一种情况，需要keepalive来检测对端是否挂掉了，比如对端服务任然运行，但是它与你之间的网络通道断开了。WIFI路由器就有这个问题。这种情况下如果网络不在了，相当于对端挂了。这就是其中的一个问题，正常的TCP操作是检测不出网络连接状态的。

考虑A和B一个简单的TCP连接：建立连接的三次握手，一个SYN段从A到B，SYN/ACK从B回到A，最后一个ACK从A到B。此时A和B处于稳定状态：ESTABLISHED。接下来就是等待方某一方通过这个稳定的通道来发送数据。
```vb
    _____                                                     _____
   |     |                                                   |     |
   |  A  |                                                   |  B  |
   |_____|                                                   |_____|
      ^                                                         ^
      |--->--->--->-------------- SYN -------------->--->--->---|
      |---<---<---<------------ SYN/ACK ------------<---<---<---|
      |--->--->--->-------------- ACK -------------->--->--->---|
```


此时问题出现了：从B上拔下电源，B会立即断开，不会通过网络发送任何信息来通知A连接即将断开。A这边，已经准备好接收数据了，还不知道B已经崩溃了。
```vb
    _____                                                     _____
   |     |                                                   |     |
   |  A  |                                                   |  B  |
   |_____|                                                   |_____|
      ^                                                         ^
      |--->--->--->-------------- SYN -------------->--->--->---|
      |---<---<---<------------ SYN/ACK ------------<---<---<---|
      |--->--->--->-------------- ACK -------------->--->--->---|
      |                                                         |
      |                                       system crash ---> X
```


恢复B的电源，等待系统重新启动。A和B重新回到原来的连接，A知道和B的网络任然是建立连接的，但B不知道。当A试图通过这个死连接向B发送数据时，B使用RST数据包进行回复，导致A最终关闭连接。
```vb
    _____                                                     _____
   |     |                                                   |     |
   |  A  |                                                   |  B  |
   |_____|                                                   |_____|
      ^                                                         ^
      |--->--->--->-------------- SYN -------------->--->--->---|
      |---<---<---<------------ SYN/ACK ------------<---<---<---|
      |--->--->--->-------------- ACK -------------->--->--->---|
      |                                                         |
      |                                       system crash ---> X
      |
      |                                     system restart ---> ^
      |                                                         |
      |--->--->--->-------------- PSH -------------->--->--->---|
      |---<---<---<-------------- RST --------------<---<---<---|
      |                                                         |
```
当另一端不可达，keepalive可以知会到你，而没有任何误报的风险。实际上如果问题发生在两端之间的网络，keepalive定时器在等待一段时间后继续重试，在将连接判断为断开前发送keepalive包。
## 2.4、防止由于网络不活动而断开连接(什么意思？)
keepalive的另一个目的是防止因为不活动而断开网络通道。 比如下面：
当你运行的服务在NAT代理或者防火墙后面时(什么鬼)，无缘无故的就断开连接。这是由代理服务器和防火墙中的连接跟踪过程引起的，它能追踪通过它们的所有连接。由于这些机器的物理限制，它们只能在内存中保留有限数量的连接。最常见的逻辑策略是保留最新的连接，并首先丢弃旧的和非活动的连接。

返回到之前A和B连接状态，只是在中间加了一个NAT服务器/代理服务器。
```vb
    _____           _____                                     _____
   |     |         |     |                                   |     |
   |  A  |         | NAT |                                   |  B  |
   |_____|         |_____|                                   |_____|
      ^               ^                                         ^
      |--->--->--->---|----------- SYN ------------->--->--->---|
      |---<---<---<---|--------- SYN/ACK -----------<---<---<---|
      |--->--->--->---|----------- ACK ------------->--->--->---|
      |               |                                         |
```
通道打开，代理等待事件发生，然后将其传递到另一个对等方。如果这个事件的验证信息需要等一段时间才返回呢？这个时间超出了代理/防火墙的判断策略呢？如果这段时间过后我们发生验证数据，结果代理没有保留我们的连接了，此时连接就中断了。
```vb
    _____           _____                                     _____
   |     |         |     |                                   |     |
   |  A  |         | NAT |                                   |  B  |
   |_____|         |_____|                                   |_____|
      ^               ^                                         ^
      |--->--->--->---|----------- SYN ------------->--->--->---|
      |---<---<---<---|--------- SYN/ACK -----------<---<---<---|
      |--->--->--->---|----------- ACK ------------->--->--->---|
      |               |                                         |
      |               | <--- connection deleted from table      |
      |               |                                         |
      |--->- PSH ->---| <--- invalid connection                 |
      |               |                                         |
```
由于防火墙/NAT的策略通常是把刚到的包的连接放在列表的顶部，在需要删除条目时删除队列中最后的一个连接，所以定期的通过网络发送数据包是一种很好的方法，使得连接始终处在顶部，避免被从队列中删除的风险。
>
>1. 内核错误(Kernel panic)是指操作系统在监测到内部的致命错误，并无法安全处理此错误时采取的动作。这个概念主要被限定在Unix以及类Unix系统中；对>于MicrosoftWindows系统，等同的概念通常被称为蓝屏死机。

# 3、在Linux下使用TCP的keepalive
## 3.1、配置内核参数
### 3.1.1、procfs接口
### 3.1.2、sysctl接口
## 3.2、重启来持久化设置
# 4、程序实例
# 5、增加对第三方软件的支持
