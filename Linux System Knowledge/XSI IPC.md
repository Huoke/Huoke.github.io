# 15.6 XSI IPC
有三种称为 XSI(System Interface and Headers 代表一种Unix系统的标准)IPC 的IPC: 消息队列、信号量和共享存储器。它们之间有很多相似之处。
>提示：
> XSI IPC 函数时紧密地基于System V 的IPC函数。这三种类型的XSI IPC源自1970年的一种称为"Columbus UNIX"的AT&T内部版本。后来被添加到System V上。由于XSI IPC
不使用文件系统命名空间，而是构造了它们自己的命名空间，为此常常受到批评

## 15.6.1 标识符和键
1. IPC标识
   内核为每个进程间通信维护一个结构体形式的IPC对象。该对象可通过一个非负整数的IPC标识来引用。与文件描述符不同，文件描述符总是找当前系统中可用的最小的数，而ipc标识符是持续加1的，它不是去取当前系统中可用的最小数作为标识符的(当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符是连续加1，直至到达一个整形的最大正值，然后又回转到0)。
2. IPC键值
   IPC标识符是IPC对象的内部名称。若多个进程需要在同一个IPC对象上会合，则必须通过键值作为其外部名称来引用该对象。
   1) 无论何时，只要创建IPC对象，就必须指定一个键值。
   2) 键值的数据类型在sys/types.h头文件中被定义为key_t，其原始类型就是长整型。
3. 客户机进程与服务器进程在IPC对象上的三种会合方式
   1) 服务器进程以IPC_PRIVATE为键值创建一个新的IPC对象，并将该IPC对象的标识存放在某处(如文件中)，以方便客户机进程读取。（内核可以保证它的唯一性）
   2) 在一个公共头文件中，定义一个客户机进程和服务器进程都认可的键值，服务器进程用此键值创建IPC对象， 客户机进程用此键值获取该IPC对象。（自己保证它的唯一性）
   3) 客户机进程和服务器进程， 事先约定好一个路径名和一个项目ID(0-255)，二者通过ftok函数，将该路径名和项目ID转换为一致的键值。（最常使用）
   ```c
   #include <sys/types.h>
   #include <sys/ipc.h>
   key_t ftok (const char* pathname, int proj_id);
   pathname - 一个真实存在的文件或目录的路径名。
   proj_id  - 项目ID，仅低8位有效，其值域为[0,255]。
   ```
   成功返回键值，失败返回-1。
注意：起作用的是pathname参数所表示的路径，而非pathname字符串本身。因此假设当前目录是/home/soft01/uc/day07，则ftok (".", 100);和ftok ("/home/soft01/uc/day07", 100);的返回值完全相同。

4. 3个get函数(msgget、semget和shmget)都是两个类似的参数: 一个key和一个整形flag。

# 15.7 消息队列
这是一个消息的链表，存储在内核中，用消息队列标识符来标识。消息队列————队列，消息队列标识符————队列ID。

- msgget用于创建一个新队列或者打开一个现有队列。
- msgsend将消息添加到队列末尾。
- msgrcv用于从队列中取得消息, 并不一定要以先进先出次序去取消息，也可以按消息的类型字段去取消息。
- msgctl对队列执行多种操作。

每一个队列都有一个msqid_ds结构体与其关联：
```c
struct msqid_ds { 
   struct ipc_perm msg_perm; // ipc 权限结构 
   msgqnum_t msg_qnum; // 队列中的数据数 
   msglen_t msg_qbytes; // 队列的最大字节容量 
   pid_t msg_lspid; // 最近插入队列数据的进程 ID 
   pid_t msg_lrpid; // 最近取出数据的进程 ID 
   time_t msg_stime; // 最近入队时间 
   time_t msg_rtime; // 最近出队时间 
   time_t msg_ctime; // 最近更新时间 
   ... 
   ... 
}  
```
该结构描述了队列的当前状态，各系统的具体实现会包含额外的字段。

影响消息队列的系统限制
| 说明 | FreeBSD 8.0 | Linux 3.2.0 | Mac OS 10.6.8 | Solaris10 |
| :----: | :----: | :----: | :----: | :----: |
| 可发送的最长消息的字节数 | 16384 | 8192 | 不支持 | 2048 |
| 一个特定队列的最大字节数(亦即队列中所有消息长度之和) | 2048 | 16384 | 不支持 | 4096 |
| 系统中最大消息队列数 | 40 | 16 | 不支持 | 50 |
| 系统中最大消息数 | 40 | 导出的 | 不支持 | 40 |

## msgget打开一个现有队列或创建一个新队列
调用的第一个函数通常是msgget，其功能是打开一个现有队列或创建一个新队列
```c
#include <sys/msg.h>
int msgget(key_t key, int flag)
返回值:若成功，返回消息队列ID， 若出错， 返回-1
```
15.6.1节中说明了将key变换成一个标识符的规则(**不怎么理解**)，并且讨论了是创建一个新队列还是引用一个现有队列。
在创建新队列时，要初始化msqid_ds结构的下列成员。
- ipc_perm结构按15.6.2节中所述进行初始化。该结构中的mode成员按flag中的相应权限位设置。这些权限用15-24中的值指定。
- msg_qnum、msg_lspid、msg_lrpid、msg_stime 和 msg_rtime都设置为0。
- msg_ctime设置为当前时间。
- msg_qbytes 设置为系统限制值。
若执行成功，msgget返回非负值的队列ID。此后，该值就可被用于其他3个消息队列函数。

## msgctl函数对队列执行多种操作
```c
#include <sys/msg.h>
int msgctl(int msqid, int cmd, struct msqid_ds* buf);
```
它和另外两个与信号量及共享存储有关的函数(semctl和shmctl)都是XSI IPC的类似于ioctl的函数(即垃圾桶函数)，这里是后话，还没有学习到信号量和共享存储有关的函数。


## 调用msgsnd将数据放到消息队列中
```c
#include <sys/msg.h>
int msgsnd(int msqid, const void* ptr, size_t nbytes, int flag);
返回值: 若成功，返回0；若出错，返回-1
```
每个消息都由3部分组成：一个正的长整型类型的字段、一个非负的长度(nbytes)、以及实际数据字节数。
消息总是放在队列尾端。

- ptr参数：指向一个长整型(long int)，它包含了消息类型(正的整型); 其后紧接着的是消息数据(若nbytes是0，则无消息数据)。若发送的最长消息是512字节，则可定义下列结构体:
```c
struct mymesg{
    long mtype; // 消息类型
    char mtext[512]; // 消息的数据部分，长度和nbytes一样
};
```
>**某些平台既支持32位环境，又支持64位环境。这影响到长整型和指针的大小**。
>例如，在64位Sparc系统中(一种基于RSIC精简指令集设计的处理器，是Sun公司独立完成)，允许32位应用程序和64位应用程序同时存在。如果一个32位应用程序要经过管道或者套接字和一个64位应用程序交换此结构，就会出问题。因为在32位应用程序中，长整型的大小是4字节，而在64位应用程序中，长整型的大小是8字节。这里就出现了一个有趣的问题：32位应用程序期望mtext字段在结构启始地址的第4个字节处开始，但是64位应用程序则期望mtext字段在结构启始地址后8字节处开始。在这种情况下，64位应用程序的mtype字段的一部分会被32位程序看做是mtext字段的组成部分；而32位程序的mtext字段的前4字节会被64位程序解释成为mtype字段的组成部分。

- flag参数：可以指定为IPC_NOWAIT。这类似于文件I/O中的非阻塞I/O标志；若消息队列已满(或者队列中的消息总数等于系统限制值，或队列中的字节总数等于系统限制值)，则指定IPC_NOWAIT使得msgsnd立即出错返回EAGAIN。
如果没有指定IPC_NOWAIT，则进程会一直阻塞到：
   1. 有空间可以容纳要发送的消息
   2. 者从系统中删除了此队列，这种情况下返回EIDRM错误，表示标识符被删除。
   3. 捕捉到一个信号，并从信号处理函数程序返回，这种情况下返回EINTR错误。

注意：
对删除消息队列的处理不是很完善。因为每个消息队列没有维护引用计数器(打开文件有这种计数器)，所以在队列被删除以后，任然在使用这一队列的进程在下次对队列进行操作时会出错返回。信号量也是这样的操作。相反，删除一个文件时，要等到使用该文件的最后一个进程关闭了它的文件描述符以后，才能删除文件中的内容。

当msgsnd返回成功时，消息队列相关的msqid_ds结构会随之更新(因为msqid_ds是表征消息队列状态的结构体0)，表明调用的进程ID(msg_lspid)、调用的时间(msg_stime)以及队列中新增的消息(msg_qnum)。
## msgrcv从队列中去取消息
```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
ssize_t msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag);
返回值：成功返回消息数据部分的长度；若出错，返回-1
```
- ptr参数：指向一个长整型数(其中存储的是返回的消息类型)，其后跟随的是存储实际消息数据的缓冲区。
- nbytes参数：指定数据缓冲区的长度。若返回的消息长度大于nbytes，而且在flag中设置了MSG_NOERROR位，则该消息会被截断(在这种情况下，没有通知告诉我们消息截断了，消息被截去的部分被丢弃)。如果没有设置这一标志位，而消息又太长，则出错返回E2BIG(消息任然留在队列中)。
- type参数：可以指定想要哪一种消息。
  type == 0 返回队列中的第一个消息
  type > 0 返回队列中消息类型为type的第一个消息
  type <0 返回队列中消息类型值小于等于type绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。

type 非0，用于以非先进先出次序读取消息。例如，若应用程序对消息赋予优先权，那么type就可以是优先权值。如果一个消息队列由多个客户进程和一个服务器进程使用，那么type字段可以用来包含客户进程的进程ID(只要进程ID可以存放在长整型中)。

- flag参数：将flag参数指定为IPC_NOWAIT，使操作不阻塞，这样，如果没有所指定类型的消息可用，则msgrcv返回-1，error设置为ENOMSG。如果没有设置IPC_NOWAIT，则进程会一直阻塞到有了指定类型的消息可用，或者从系统中删除了此队列，返回-1，errno设置为EIDRM；或者捕捉到一个信号并从信号处理程序返回，导致msgrcv返回 -1， errno设置为EINTR。

msgrcv成功执行时，内核会更新与该消息队列相关的msgid_ds结构，以指示调用者的进程ID(msg_lrpid)和调用时间(msg_rtime)，并指示队列中的消息数减少了1个(msg_qnum)。

-----
